Идея:
1. соберем путь по порядку вхождения вершин в вектор Data
2. выкинем три самых тяжелых ребра
   	   проблема: искать их перебором - O(n) доп. времени, О(1) по памяти / хранить длины ребер
	             вместе с вершинами - поиск О(1) по времени, О(n) по памяти. С другой стороны можно
		     подвязать иерархическую структуру данных - будет pog
3. если хранить веса ребер, инцидентных вершинам, то легко понять какие есть способы дозамкнуть множество
   ребер до гамильтонова пути. Достроим граф, минимизируя сумму новых длин
4. если на шаге 3 общая длина пути изменилась - повторить
   если не изменилась - попробовать выкинуть 4, 5 и 6 по длине ребра и повторить.

Пахнет рекурсией, каждый раз искать k-ые статистики становится совсем не весело. Точно вспомнить структуры
данных, освежить в памяти алгоритмы